\hypertarget{structrs__buffers__s}{}\section{rs\+\_\+buffers\+\_\+s Struct Reference}
\label{structrs__buffers__s}\index{rs\+\_\+buffers\+\_\+s@{rs\+\_\+buffers\+\_\+s}}


{\ttfamily \#include $<$librsync.\+h$>$}

\subsection*{Public Attributes}
\begin{DoxyCompactItemize}
\item 
char $\ast$ \hyperlink{structrs__buffers__s_a6d5d12a1ced9a3a8891259e09c80ec20}{next\+\_\+in}
\item 
size\+\_\+t \hyperlink{structrs__buffers__s_a7bd5f1ea3c26587bf1106c1594712735}{avail\+\_\+in}
\item 
int \hyperlink{structrs__buffers__s_aa6783da2d894c77178155759cd12d16f}{eof\+\_\+in}
\item 
char $\ast$ \hyperlink{structrs__buffers__s_af3a6532c3e300a07783d61680cbdc11f}{next\+\_\+out}
\item 
size\+\_\+t \hyperlink{structrs__buffers__s_ae60f3db2f518d74aee13a02b7c9619a2}{avail\+\_\+out}
\end{DoxyCompactItemize}


\subsection{Detailed Description}
Stream through which the calling application feeds data to and from the library.

On each call to rs\+\_\+job\+\_\+iter, the caller can make available


\begin{DoxyItemize}
\item avail\+\_\+in bytes of input data at next\+\_\+in
\item avail\+\_\+out bytes of output space at next\+\_\+out
\item some of both
\end{DoxyItemize}

Buffers must be allocated and passed in by the caller. This routine never allocates, reallocates or frees buffers.

Pay attention to the meaning of the returned pointer and length values. They do {\bfseries not} indicate the location and amount of returned data. Rather, if {\ttfamily $\ast$out\+\_\+ptr} was originally set to {\ttfamily out\+\_\+buf}, then the output data begins at {\ttfamily out\+\_\+buf}, and has length {\ttfamily $\ast$out\+\_\+ptr} -\/ {\ttfamily out\+\_\+buf}.

Note also that if {\ttfamily $\ast$avail\+\_\+in} is nonzero on return, then not all of the input data has been consumed. The caller should either provide more output buffer space and call rs\+\_\+work() again passing the same {\ttfamily next\+\_\+in} and {\ttfamily avail\+\_\+in}, or put the remaining input data into some persistent buffer and call rs\+\_\+work() with it again when there is more output space.


\begin{DoxyParams}{Parameters}
{\em next\+\_\+in} & References a pointer which on entry should point to the start of the data to be encoded. Updated to point to the byte after the last one consumed.\\
\hline
{\em avail\+\_\+in} & References the length of available input. Updated to be the number of unused data bytes, which will be zero if all the input was consumed. May be zero if there is no new input, but the caller just wants to drain output.\\
\hline
{\em next\+\_\+out} & References a pointer which on entry points to the start of the output buffer. Updated to point to the byte after the last one filled.\\
\hline
{\em avail\+\_\+out} & References the size of available output buffer. Updated to the size of unused output buffer.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The \hyperlink{librsync_8h_a7feb858ceba3b8f3cf048d49be108253}{rs\+\_\+result} that caused iteration to stop.
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\hyperlink{librsync_8h_abf9f543dbfe5c1e60c8ed1c93d087767}{rs\+\_\+buffers\+\_\+t} 

api\+\_\+buffers 
\end{DoxySeeAlso}


Definition at line 262 of file librsync.\+h.



\subsection{Member Data Documentation}
\hypertarget{structrs__buffers__s_a7bd5f1ea3c26587bf1106c1594712735}{}\index{rs\+\_\+buffers\+\_\+s@{rs\+\_\+buffers\+\_\+s}!avail\+\_\+in@{avail\+\_\+in}}
\index{avail\+\_\+in@{avail\+\_\+in}!rs\+\_\+buffers\+\_\+s@{rs\+\_\+buffers\+\_\+s}}
\subsubsection[{avail\+\_\+in}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t rs\+\_\+buffers\+\_\+s\+::avail\+\_\+in}\label{structrs__buffers__s_a7bd5f1ea3c26587bf1106c1594712735}
Number of bytes available at next\+\_\+in 

Definition at line 264 of file librsync.\+h.

\hypertarget{structrs__buffers__s_ae60f3db2f518d74aee13a02b7c9619a2}{}\index{rs\+\_\+buffers\+\_\+s@{rs\+\_\+buffers\+\_\+s}!avail\+\_\+out@{avail\+\_\+out}}
\index{avail\+\_\+out@{avail\+\_\+out}!rs\+\_\+buffers\+\_\+s@{rs\+\_\+buffers\+\_\+s}}
\subsubsection[{avail\+\_\+out}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t rs\+\_\+buffers\+\_\+s\+::avail\+\_\+out}\label{structrs__buffers__s_ae60f3db2f518d74aee13a02b7c9619a2}
Remaining free space at next\+\_\+out 

Definition at line 269 of file librsync.\+h.

\hypertarget{structrs__buffers__s_aa6783da2d894c77178155759cd12d16f}{}\index{rs\+\_\+buffers\+\_\+s@{rs\+\_\+buffers\+\_\+s}!eof\+\_\+in@{eof\+\_\+in}}
\index{eof\+\_\+in@{eof\+\_\+in}!rs\+\_\+buffers\+\_\+s@{rs\+\_\+buffers\+\_\+s}}
\subsubsection[{eof\+\_\+in}]{\setlength{\rightskip}{0pt plus 5cm}int rs\+\_\+buffers\+\_\+s\+::eof\+\_\+in}\label{structrs__buffers__s_aa6783da2d894c77178155759cd12d16f}
True if there is no more data after this. 

Definition at line 265 of file librsync.\+h.

\hypertarget{structrs__buffers__s_a6d5d12a1ced9a3a8891259e09c80ec20}{}\index{rs\+\_\+buffers\+\_\+s@{rs\+\_\+buffers\+\_\+s}!next\+\_\+in@{next\+\_\+in}}
\index{next\+\_\+in@{next\+\_\+in}!rs\+\_\+buffers\+\_\+s@{rs\+\_\+buffers\+\_\+s}}
\subsubsection[{next\+\_\+in}]{\setlength{\rightskip}{0pt plus 5cm}char$\ast$ rs\+\_\+buffers\+\_\+s\+::next\+\_\+in}\label{structrs__buffers__s_a6d5d12a1ced9a3a8891259e09c80ec20}
Next input byte 

Definition at line 263 of file librsync.\+h.

\hypertarget{structrs__buffers__s_af3a6532c3e300a07783d61680cbdc11f}{}\index{rs\+\_\+buffers\+\_\+s@{rs\+\_\+buffers\+\_\+s}!next\+\_\+out@{next\+\_\+out}}
\index{next\+\_\+out@{next\+\_\+out}!rs\+\_\+buffers\+\_\+s@{rs\+\_\+buffers\+\_\+s}}
\subsubsection[{next\+\_\+out}]{\setlength{\rightskip}{0pt plus 5cm}char$\ast$ rs\+\_\+buffers\+\_\+s\+::next\+\_\+out}\label{structrs__buffers__s_af3a6532c3e300a07783d61680cbdc11f}
Next output byte should be put there 

Definition at line 268 of file librsync.\+h.



The documentation for this struct was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
/\+Users/\+Zheng/\+Desktop/librsync-\/0.\+9.\+7/\hyperlink{librsync_8h}{librsync.\+h}\end{DoxyCompactItemize}
